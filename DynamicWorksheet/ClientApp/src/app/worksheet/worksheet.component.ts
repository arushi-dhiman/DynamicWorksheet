import { AfterViewInit, Component, OnInit } from '@angular/core';import { SharedService } from '../../Services/SharedService';import { FieldModel, FormDataModel, TabModel, TemplateModel, OptionModel } from '../../models/template';//Importing JSON file import templateConfig from '../../../worksheetTemplates.json'import { FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';import { SaveTemplateDataModel, Record } from 'src/models/dynamicForm';import { FindingModel, SelectedStatementOption, Statement } from 'src/models/findingsModel';import { FindingApiService } from 'src/Services/FindingApiService';import { TemplatesService } from '../../Services/TemplatesService';import { ToastrService } from 'ngx-toastr';@Component({  selector: 'app-worksheet',  templateUrl: './worksheet.component.html',  styleUrls: ['./worksheet.component.css']})export class WorksheetComponent implements OnInit, AfterViewInit {  isFormOpen = true;  activeTabIndex = 0;  templateData: any;  templateId = 0;  FormData: any;  TabData: any;  mainForm!: FormGroup;  ImagePreviewLink = null;  IsModelShow = false;  ImagePreviewTitle = null;  findingsArray: FindingModel[] = [];  sortedFindings: any = this.findingsArray;  sortOrder: 'asc' | 'desc' = 'asc';  findings = [];  dbRecords = [];  addedFields: any[] = [];  dynamicId: number = 0;  isClearButton: boolean = false;  userId = 1;  dynamicFields: any = []  showDynamicGrid: { [key: string]: boolean } = {};  dynamicRows: { FieldId: number, FieldName: string, Values: any }[] = [];  private originalFindingsArray: any[] = [];
  constructor(    private sharedService: SharedService,    private fb: FormBuilder,    private findingApiService: FindingApiService,    private records: TemplatesService,    private toastr: ToastrService  ) {    this.sharedService.currentTemplateId.subscribe((id) => {      this.templateId = id;      //this.templateId = 5;      this.templateData = templateConfig.Templates.find(template => template.TemplateId == this.templateId) as TemplateModel;      if (this.templateData != null && this.templateData != undefined) {        this.TabData = this.templateData.Tabs as TabModel;        // sort the tab array based on tabIndex        this.TabData.sort((a, b) => a.TabId - b.TabId);        //Get formData From Tab array index 0        this.activeTabIndex = this.templateData.Tabs[0].TabId;        this.FormData = this.templateData.Tabs[0].FormData;      }    });  }  ngOnInit() {    this.getFindings();    if (this.templateData != null && this.templateData != undefined && this.FormData != null && this.FormData != undefined && this.FormData.length != 0)      this.initMainForm();  }  //Retrieves findings from database   getFindings() {    this.findingApiService.getFindingsList().subscribe(      (data: FindingModel[]) => {        this.findings = data;      },      (error: any) => {        console.error(error);      }    );  }  ngAfterViewInit() {  }  //Initializing main form  initMainForm() {    let tabGroupConfig: any = {};    this.TabData.forEach((tab: TabModel) => {      let formGroupConfig: any = {};      tab.FormData.forEach((form: FormDataModel) => {        let controlsConfig: any = {};        form.Fields.forEach((Field: FieldModel) => {          controlsConfig[Field.FieldName + '_' + Field.FieldId] = [null];        });        formGroupConfig[form.FormName] = this.fb.group(controlsConfig);      });      tabGroupConfig[tab.TabName] = this.fb.group(formGroupConfig)    })    this.mainForm = this.fb.group(tabGroupConfig);    this.getRecords();  }  //Retrieves records associated with a specific user ID   getRecords() {    this.records.getRecords(this.userId, this.templateId).subscribe(      (response: any) => {        this.dbRecords = response.records;        this.findingsArray = response.jsonResult;        this.originalFindingsArray = JSON.parse(JSON.stringify(this.findingsArray));  // Store the original state        this.bindRecords();      },      (error: any) => {        console.error(error);      }    );  }  //Binds database records to corresponding form controls in a dynamic form, updating values based on the retrieved data.  bindRecords() {    if (this.dbRecords && this.dbRecords.length > 0) {      console.log("database records ",this.dbRecords)      Object.keys(this.mainForm.controls).forEach((tab,index) => {        const formGroup = this.mainForm.get(tab) as FormGroup;        const forms = formGroup.controls;        Object.keys(forms).forEach((form,i) => {          const controlGroup = this.mainForm.get(tab).get(form) as FormGroup;          const fields = controlGroup.controls;          Object.keys(fields).forEach(field => {            let fieldId = field.split('_')[field.split('_').length - 1]            const fieldData = this.mainForm.get(tab).get(form).get(field) as FormControl;            const foundTemplateField = this.templateData.Tabs[index].FormData[i].Fields.find((element) => {              return element.FieldId == fieldId            });            let foundRes = this.dbRecords.find(res => res.fieldId == fieldId);            if (foundRes && foundTemplateField.IsDynamic) {              if (foundRes.isMultipleValues) {                this.dynamicRows.push({                  FieldId: foundRes.fieldId,                  FieldName: foundRes.fieldName,                  Values: JSON.parse(foundRes.fieldValue)                })                this.showDynamicGrid[fieldId] = true;              } else {
                  fieldData.setValue(foundRes.fieldValue);
                }
              }
            else if (foundRes && !foundTemplateField.IsDynamic) {              if (foundTemplateField.FieldType == 'Checkbox') {                fieldData.setValue(foundRes.fieldValue === 'true' ? true : false);
              }              else {                fieldData.setValue(foundRes.fieldValue);
              }
             }           })        })      })    }  }  tabChange(tabId: number) {    this.activeTabIndex = tabId  }  toggleform() {    this.isFormOpen = !this.isFormOpen;  }  //Submits template field data for saving, considering touched and dirty fields, and handles dynamic fields with multiple values.  onMainFormSubmit() {    let fieldobject = new SaveTemplateDataModel();    fieldobject.IsClear = this.isClearButton;    fieldobject.UserId = this.userId;    fieldobject.TemplateId = this.templateId;    const tabs = Object.keys(this.mainForm.controls);    tabs.forEach((tab, index) => {      const formGroup = this.mainForm.get(tab) as FormGroup;      const forms = formGroup.controls;      Object.keys(forms).forEach((form, i) => {        const controlGroup = this.mainForm.get(tab).get(form) as FormGroup;        const fields = controlGroup.controls;        Object.keys(fields).forEach((field, fieldIndex) => {          const fieldData = this.mainForm.get(tab).get(form).get(field) as FormControl;          const touched = fieldData?.touched;          const pendingDirty = fieldData['_pendingDirty']          //If the field touched is true, pendingDirty is true, and pendingValue is not null          if (touched === true && pendingDirty === true ) {            let fieldId = field.split('_')[field.split('_').length - 1]            const record = new Record()            const foundTempalteField = this.templateData.Tabs[index].FormData[i].Fields.find((element) => {              return element.FieldId == fieldId            });            record.FieldId = foundTempalteField.FieldId;            record.UserId = this.userId;            //if dynamic field than search in Dynamic field array            if (foundTempalteField.IsDynamic === true) {              let foundDynamicData = this.dynamicRows.find(item => { return item.FieldId == foundTempalteField.FieldId})              if (foundDynamicData) {                record.IsMultipleValues = true;                record.FieldValue = JSON.stringify(foundDynamicData.Values);              } else {                record.FieldValue = (fieldData.value==null) ? '' : fieldData.value.toString();                record.IsMultipleValues = false;              }            } else {              record.FieldValue = fieldData.value.toString();              record.IsMultipleValues = false;            }            //check if record already exist or not            let dbRecord = this.dbRecords.find(item => { return item.fieldId == foundTempalteField.FieldId })            if (dbRecord && !this.isClearButton) {              record.Id = dbRecord.id;            }            fieldobject.TemplateFields.push(record );          }        })      });    });    // traverse through each control and check if they are touch and dirty if yes then get their value    if (fieldobject.TemplateFields == null || fieldobject.TemplateFields.length < 1) {      this.toastr.warning('Please enter atleast one record');    }    else {      this.saveDataToDatabase(fieldobject);    }  }  //Resets the main form, clears dynamic rows, and updates flags to indicate a standard reset.  mainFormReset() {    this.isClearButton = false;    this.mainForm.reset();    this.dynamicRows = [];    this.showDynamicGrid = {}  }  //Sends request to save records to the database.  saveDataToDatabase(obj) {    if (obj.TemplateFields !== null && obj.TemplateFields.length > 0) {      this.records.saveRecords(obj).subscribe(        response => {          if (response !== null && response.length > 0) {            this.toastr.success('Success', 'Data successfully saved');            this.mainFormReset();            this.dbRecords = response;            this.bindRecords();          }          else {            this.toastr.error('Error', 'Something went wrong');          }        },        error => {          this.toastr.error('Error', 'Something went wrong');        }      )    }  }  //Retrieves the FormGroup instance corresponding to a specific form.  getFormGroupAt(formName: string, tabName: string): FormGroup {    return this.mainForm.get(tabName).get(formName) as FormGroup;  }  //Retrieves the FormGroup instance corresponding to a specific tab.  getTabGroupAt(tabName: string): FormGroup {    return this.mainForm.get(tabName) as FormGroup;  }  //Toggles the visibility of a modal by updating the IsModelShow property.  ToggleModel(link = null, title = null) {    this.IsModelShow = (this.IsModelShow) ? false : true;    if (this.IsModelShow) {      this.ImagePreviewLink = link;      this.ImagePreviewTitle = title;      document.body.classList.add('modal-open');    }    else {      document.body.classList.remove('modal-open');    }  }  getArray(length: number): number[] {    return Array(length).fill(0).map((x, i) => i);  }  //Checks if the provided fieldId is part of a dynamic row and removes references to the specified fieldId and fieldOptionId from the FieldIds property within the statements.  checkAndRemoveFieldReference(fieldId: number,fieldOptionId:number) {    if (this.findingsArray == null || this.findingsArray.length < 1) {      return    }    //check If FieldOption is part of DynamicRow than return    console.log('dynamicRow', this.dynamicRows);    let foundField = this.dynamicRows.find((row) => (row.FieldId == fieldId))    let isDynamicField = foundField?true:false    //travese thorough the FindingArray and statement Array and remove the field Reference     this.findingsArray.forEach(findingSection => {      findingSection.statements.forEach(statments => {        // check if fieldId is present        let filteredFieldIds = statments.fieldIds.filter(fields => {          console.log(fields)          //check if fieldOptionId is part of dynamicField          if (isDynamicField) {          let dynamicFieldOption = this.dynamicRows.find(rows => rows.FieldId == fieldId).Values;
            // if passed fieldOptionId is in dynamic field than don't do anything 
            let isfound = dynamicFieldOption.find(option => option.fieldOptionId == fields.fieldOptionId)
            return (!(fields.fieldId == fieldId && !isfound));
          } else {            return (fields.fieldId != fieldId && fields.fieldOptionId != fieldOptionId)
          }
        })        statments.fieldIds = filteredFieldIds;      })    })    //travese thorough the FindingArray and statement Array and remove the statement Reference if FieldID is empty      this.findingsArray.forEach(findingSection => {      findingSection.statements = findingSection.statements.filter(statments => {        return statments.fieldIds.length>0      })    })    //travese thorough the FindingArray and statement Array and remove the statement Reference if FieldID is empty    this.findingsArray=this.findingsArray.filter(findingSection => {      return findingSection.statements.length > 0    })  }  //Handles the logic when there's a change in the input which in turn deals with displaying findings and statements in finding block  onInputChange(TabName: string, FormName: string, FieldName: string, FieldOption: any = null, formControl) {    let field = this.mainForm.get(TabName).get(FormName).get(FieldName);    const selectedIndex = FieldOption.selectedIndex;    let fieldId = this.getFieldIdFromFieldControlName(FieldName);    //gurding method: if FieldOptionId is not associated than return    if ((selectedIndex == null || selectedIndex == undefined) && FieldOption == null) {
      return;
    }

    const fieldOptionId = FieldOption != null && selectedIndex == undefined ? FieldOption : FieldOption.options[selectedIndex].getAttribute('data-FieldOptionId');    const statements = this.findings.filter(f => { return f.fieldOptionId == fieldOptionId })    //Remove the fieldId reference from previous choice and If statment from array if required and not a part of dynamic Rows     this.checkAndRemoveFieldReference(fieldId, fieldOptionId);    //this.modifyFindings(fieldId);    this.addFinding(fieldOptionId, statements, fieldId);    //Checks if fieldType is checkbox, on unchecking it, removes the finding reference.    if (formControl.FieldType == 'Checkbox' && field.value == false) {        this.checkAndRemoveFieldReference(fieldId, fieldOptionId);
    }    console.log('Fndings', this.findingsArray);  }  //Takes a fieldOptionId, an array of statements, and a fieldId as parameters. It searches for existing findings in an array based on the provided fieldOptionId  addFinding(fieldOptionId, statements, fieldId) {    // find the all the finding obejct that consist passed fieldOptionId, Returntype FindingModel[]    let foundFinding = this.getAllFindingByFieldOptionId(fieldOptionId);    // check in existing finding array, if finding exist than add the statement if not push add new finding and add the passed statement     if (foundFinding != null && foundFinding.length > 0) {      foundFinding.forEach((finding) => {        let foundFindingSection = this.findingsArray.find(findingSection => {          return findingSection.findingId == finding.findingId;        });        let statementObjs = this.getStatementObject(finding.findingId, statements, fieldId, fieldOptionId);        //Add the new statement in the found finding section         if (foundFindingSection) {          statementObjs.forEach(statement => {            // if statement donsen't exist in finding section than add            let foundStatementIndex = foundFindingSection.statements.findIndex(statementinner => {              return statementinner.statementId == statement.statementId;            })            if (foundStatementIndex != -1) {              //check for FieldId If Exist than do nothing else add FieldId              // foundFindingSection.statements.splice(foundStatementIndex);              let idIndex = foundFindingSection.statements[foundStatementIndex].fieldIds.findIndex(field => field.fieldId == fieldId);              if (idIndex == -1) {                foundFindingSection.statements[foundStatementIndex].fieldIds.push(new SelectedStatementOption(fieldId, fieldOptionId))              }            }            else {              foundFindingSection.statements.push(statement);            }          })        }        // Add new Finding Section        else {          let findingObject = new FindingModel();          findingObject.findingId = finding.findingId;          findingObject.findingOrder = finding.findingOrder;          findingObject.findingTitle = finding.findingTitle;          findingObject.statements = statementObjs;          this.findingsArray.push(findingObject)        }      })      //sort the finding       if (this.sortOrder === 'asc') {        const scrollingContainer = document.getElementById('scrolling-container');        if (scrollingContainer) {          scrollingContainer.scrollTop = scrollingContainer.scrollHeight;          this.findingsArray.sort((a, b) => a.findingOrder - b.findingOrder);        }      } else {        document.getElementById('scrolling-container').scrollTop = 0;        this.findingsArray.sort((a, b) => b.findingOrder - a.findingOrder);      }      console.log('FindingArray', this.findingsArray);    }  }  // find the all the finding obejct that consist passed statementId  getAllFindingByFieldOptionId(fieldOptionId: number) {    let foundFieldOption = this.findings.filter((finding: any) => {      return finding.fieldOptionId == fieldOptionId    })    let Findings = [];    foundFieldOption.forEach((foundFieldOption) => {      if (foundFieldOption.findings) {        foundFieldOption.findings.forEach(findingItem => {          let result = Findings.find(f => f.findingId == findingItem.findingId);          if (!result) {            Findings.push(findingItem);          }        })      }    })    return Findings;  }  // find the statment object the finding obejct that consist passed statementId  getStatementObject(findingId, statements, fieldId, fieldOptionId): Statement[] {    let responseStatements = [];    statements.forEach((statement) => {      let found = statement.findings.find((finding) => {        return finding.findingId == findingId      });      if (found) {        let statementObj = new Statement();        statementObj.statementId = statement.statementId        statementObj.description = statement.statement        statementObj['fieldIds'] = [new SelectedStatementOption(fieldId, parseInt(fieldOptionId))];        responseStatements.push(statementObj);      }    })    return responseStatements ? responseStatements :null ;  }  //Toggles the sorting order (ascending or descending) of the findingsArray and update the sortedFindings.  toggleSortOrder(): void {    this.sortOrder = this.sortOrder === 'asc' ? 'desc' : 'asc';    if (this.sortOrder === 'asc') {      this.findingsArray.sort((a, b) => a.findingOrder - b.findingOrder);      document.getElementById('scrolling-container').scrollTop = document.getElementById('scrolling-container').scrollHeight;    } else {      this.findingsArray.sort((a, b) => b.findingOrder - a.findingOrder);;      document.getElementById('scrolling-container').scrollTop = 0;    }  }  //Resets form when 'RESET' button is clicked.  resetForm() {    console.log('original array findings ' ,this.originalFindingsArray)    this.mainFormReset();    this.bindRecords();    // Reset findingsArray to its original state using deep copy    this.findingsArray = JSON.parse(JSON.stringify(this.originalFindingsArray));    this.toastr.success('Success', 'Data reset successfully');  }  //Clears form when 'CLEAR' button is clicked.  clearForm() {    this.mainFormReset();    this.findingsArray.splice(0, this.findingsArray.length);    this.isClearButton = true;    this.findingsArray = [];    this.toastr.success('Success', 'All data cleared');  }  //Handles the addition of a dynamic field value to the dynamicRows array based on user input.   addField(TabName: string, FormName: string, FieldName: string, formControl: any, fieldOptionId: any) {    let form = this.mainForm.get(TabName).get(FormName) as FormGroup;    let fieldData = this.mainForm.get(TabName).get(FormName).get(FieldName).value;    let fieldOption;    if (formControl.FieldType == 'DropDown') {      fieldOption = formControl.Options.find(f => {        return f.Id == fieldData;      });    }    else {      fieldOption = fieldOptionId    }    // if the control value is empty and null throw warning     if (fieldData != null && fieldData != '' && fieldData != undefined && formControl.IsDynamic) {      //if not than check if dynamicRow has already field with same id or not      // if yes than add value in found field else add new field      let foundDynamicField = this.dynamicRows.find((item) => { return item.FieldId == formControl.FieldId })      if (foundDynamicField != null && foundDynamicField != undefined) {        foundDynamicField.Values.push({          fieldOptionId: (formControl.FieldType == "DropDown") ? fieldOption.FieldOptionId : fieldOption,          value: fieldData,          TextValue: (formControl.FieldType == "DropDown" || formControl.FieldType == "Radio") ? this.getOptionValue(FormName, parseInt(formControl.FieldId), parseInt(fieldData)) : fieldData        });      }      else {        this.dynamicRows.push({          FieldId: formControl.FieldId,          FieldName: formControl.FieldName,          Values: [            {              fieldOptionId: (formControl.FieldType == "DropDown") ? fieldOption.FieldOptionId : fieldOption,              value: fieldData,              TextValue: (formControl.FieldType == "DropDown" || formControl.FieldType == "Radio") ? this.getOptionValue(FormName, parseInt(formControl.FieldId), parseInt(fieldData)) : fieldData            }          ]        })      }      this.showDynamicGrid[parseInt(formControl.FieldId)] = true;      this.mainForm.get(TabName).get(FormName).get(FieldName).setValue('');    } else {      this.toastr.warning('Please select value first');    }    console.log("Dynamic Rows", this.dynamicRows)  }  //Retrieves the Option Text of an option based on option ID.   getOptionValue(formName: string, fieldId: number, optionId: number): string | undefined {    const template = templateConfig.Templates.find(t => t.TemplateId === this.templateId);    if (template) {      for (const tab of template.Tabs) {        for (const formData of tab.FormData) {          if (formData.FormName === formName) {            const selectedField = formData.Fields.find(field => field.FieldId === fieldId);            if (selectedField && ('Options' in selectedField)) {              const option = (selectedField as { Options: any }).Options.find(o => o.Id === optionId);              if (option) {                return option.Value;              }            }          }        }      }    }    return undefined;  }  //Gets fieldId for a specific fieldName  getFieldIdFromFieldControlName(fieldName: string): number{    return parseInt( fieldName.split('_')[fieldName.split('_').length - 1])  }  //Designed to remove a specific item from a dynamic row within a form.   removeFieldItem(TabName: string, FormName: string, FieldName: string, dynamicRow: any, fieldrowIndex: number, valueIndex: number) {    // Logic to remove the field based on the dynamicRow and value index.    //if values has only one item than remove dynamic field from array else remove value from value arrays    if (dynamicRow.Values.length > 1) {      this.dynamicRows[fieldrowIndex].Values.splice(valueIndex, 1);      console.log(this.dynamicRows);    }    else {      this.showDynamicGrid[dynamicRow.FieldId] = false;      this.dynamicRows.splice(fieldrowIndex, 1);      console.log(this.mainForm);    }    this.mainForm.get(TabName).get(FormName).get(FieldName).markAsTouched();    this.mainForm.get(TabName).get(FormName).get(FieldName)['_pendingDirty'] = true;    // remove the finding    this.checkAndRemoveFieldReference(dynamicRow.FieldId, -1);  }}